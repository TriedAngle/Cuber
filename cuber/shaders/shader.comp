#version 460

const int RAY_BOUNCES = 8;
const int MAX_RAY_STEPS = 128;

struct Chunk {
    uint voxels[16];
};

struct Material {
    vec3 albedo;
    float reflectivity;
    float metallicity;
    float transparency;
    float emission;
};

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) buffer Chunks {
    Chunk chunks[];
};

layout(std430, binding = 1) buffer Materials {
    Material materials[];
};

// TODO: use rgba16ui or srgba8_alpha for albedo and rgba8 for normal
// also investigate how the a part can be dropped in both
// its' just a bit annoying because I can't reuse the shader then :(
layout (rgba32f, binding = 0) uniform image2D albedoTexture;
layout (r16f, binding = 1) uniform image2D depthTexture;
layout (rgba16f, binding = 2) uniform image2D normalTexture;

uniform vec3 cameraPos;
uniform vec3 cameraDir;
uniform vec3 cameraU;
uniform vec3 cameraV;
uniform uint timer;
uniform float randomSeed;

uint hash(uint x) {
    x += (x << 10u);
    x ^= (x >>  6u);
    x += (x <<  3u);
    x ^= (x >> 11u);
    x += (x << 15u);
    return x;
}
uint hash(uvec2 v) {
    return hash(v.x^hash(v.y));
}
uint hash(uvec3 v) {
    return hash(v.x^hash(v.y)^hash(v.z));
}
uint hash(uvec4 v) {
    return hash(v.x^hash(v.y)^hash(v.z)^hash(v.w));
}
float random(float f) {
    const uint mantissaMask = 0x007FFFFFu;
    const uint one = 0x3F800000u;
   
    uint h = hash(floatBitsToUint(f));
    h &= mantissaMask;
    h |= one;
    
    float  r2 = uintBitsToFloat(h);
    return r2 - 1.0;
}
float random(vec2 v) {
    return random(floatBitsToUint(hash(uvec2(v.x, v.y))));
}
float random(vec3 v) {
    return random(floatBitsToUint(hash(uvec3(v.x, v.y, v.z))));
}
float random(vec4 v) {
    return random(floatBitsToUint(hash(uvec4(v.x, v.y, v.z, v.w))));
}

float sdSphere(vec3 p, float d) { 
    return length(p) - d; 
} 

float sdBox(vec3 p, vec3 b) {
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}
	
bool getVoxel(ivec3 c) {
    vec3 p = vec3(0.0, 0.0, 0.0) - c;
    float d = 1e10;
	d = min(d, max(-sdSphere(p, 23.5), sdBox(p, vec3(20.0))));
	return d < 0.0;
}

bool hitVoxel(Chunk chunk, ivec3 pos) {
    int index = pos.x * 64 + pos.y * 8 + pos.z;
    int pack_index = index % 32;
    int array_index = index / 32;
    uint pack = chunk.voxels[array_index];
    uint mask = 1 << pack_index;
    bool value = (pack & mask) != 0;
    return value;
}

bool hitChunk(Chunk chunk, inout ivec3 gridPos, inout vec3 sideDist, inout bvec3 mask, ivec3 gridStep, vec3 deltaDist) {
    ivec3 chunk_pos = ivec3(gridPos.x % 8, gridPos.y % 8, gridPos.z % 8);
    for (int i = 0; i < 8; i++) {
        if (any(lessThan(chunk_pos, ivec3(0))) || any(greaterThanEqual(chunk_pos, ivec3(8)))) {
            break;
        }
        if (hitVoxel(chunk, chunk_pos)) {
            return true;
        }
        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));
        sideDist += vec3(mask) * deltaDist;
        chunk_pos += ivec3(vec3(mask)) * gridStep;
        gridPos += ivec3(vec3(mask)) * gridStep;
    }
    return false;
}

struct RayHit {
    vec3 pos;
    vec3 dir;    
    bvec3 mask;
    float dist;
    uint material_id;
};

RayHit traceRay(vec3 pos, vec3 dir) {
    ivec3 gridPos = ivec3(floor(pos));
    vec3 deltaDist = abs(vec3(length(dir)) / dir);

    ivec3 gridStep = ivec3(sign(dir));

    vec3 sideDist = 
        (sign(dir) * (vec3(gridPos) - pos) + (sign(dir) * 0.5) + 0.5) * deltaDist;

    Chunk test_chunk = chunks[0];
    bool hit = false;
    bvec3 mask;

    for (int i = 0; i < MAX_RAY_STEPS; i++) {
        if (gridPos.x >= 0 && gridPos.x < 8 &&
            gridPos.y >= 0 && gridPos.y < 8 &&
            gridPos.z >= 0 && gridPos.z < 8 &&
            hitChunk(test_chunk, gridPos, sideDist, mask, gridStep, deltaDist)) {
            hit = true;
            break;
        }
        if(getVoxel(gridPos)) {
            hit = true;
            break; 
        }
        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));
        sideDist += vec3(mask) * deltaDist;
        gridPos += ivec3(vec3(mask)) * gridStep;
    }

    float hitDistance;

    if (mask.x) {
        hitDistance = (sideDist.x - deltaDist.x) / dir.x;
    } else if (mask.y) {
        hitDistance = (sideDist.y - deltaDist.y) / dir.y;
    } else {
        hitDistance = (sideDist.z - deltaDist.z) / dir.z;
    }
    vec3 hitPosition = pos + hitDistance * dir;

    if (!hit) {
        return RayHit(hitPosition, dir, bvec3(0), hitDistance, 0);
    }

    return RayHit(hitPosition, dir, mask, hitDistance, 0);
}




void main ( ) { 
    ivec2 texPos = ivec2(gl_GlobalInvocationID.xy);
    float aspectRatio = 1280.0 / 720.0;
    vec2 screenPos = vec2(gl_GlobalInvocationID.xy) / vec2(1280.0, 720.0) * 2.0 - 1.0;
    screenPos.x *= aspectRatio;

    vec3 cameraPlaneU = cameraU;
	vec3 cameraPlaneV = cameraV;

    vec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;
    vec3 rayPos = cameraPos;

    RayHit hit = traceRay(rayPos, rayDir);

    vec3 albedo = vec3(0.0);
    vec3 normal = vec3(0.0);
    float depth;
    if (hit.mask == bvec3(0)) depth = 1.0;
    else depth = length(hit.dist) / float(MAX_RAY_STEPS);
    if (hit.mask.x) {
        albedo = vec3(0.5);
        if (hit.dir.x >= 0.0) normal = vec3(1.0, 0.0, 0.0);
        else normal = vec3(-1.0, 0.0, 0.0);
    } else if (hit.mask.y) {
        albedo = vec3(1.0);
        if (hit.dir.y >= 0.0) normal = vec3(0.0, 1.0, 0.0);
        else normal = vec3(0.0, -1.0, 0.0);
    } else if (hit.mask.z) {
        albedo = vec3(0.75);
        if (hit.dir.z >= 0.0) normal = vec3(0.0, 0.0, 1.0);
        else normal = vec3(0.0, 0.0, -1.0);
    }
    imageStore(albedoTexture, texPos, vec4(albedo, 1.0));
    imageStore(depthTexture, texPos, vec4(depth));
    imageStore(normalTexture, texPos, vec4(normal, 1.0));
}
